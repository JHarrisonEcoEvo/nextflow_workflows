#!/usr/bin/env nextflow
//=============================================================================
//              gbs_nextflow - A tool to ease RADseq bioinformatics
//                                  J. Harrison
//  Usage: nextflow gbs_nextflow --in --key --path_out --dbpath --mode
//  Example: nextflow gbs_nextflow --in data/sample1.fastq --key data/samplekey.csv
//   --path_out ./data/ --dbpath ./contaminants/ --mode denovo
//
//
//  "in" - is a path to a directory with unzipped single-end reads
//  from a RADseq experiment. Reads should be fastq formatted.
//  "key" -- The demultiplexing key, which should have three columns:
//  well, sequence, sample. See example data to view expected formatting.
//  "path_out" - The output path, which can be wherever you want the files output by
//  this workflow to be written.
//  "dbpath" -is the path to a directory with bowtie formatted contaminant
//  databases.
//  "mode" - is the assembly
//
// Each process will be explained at the beginning of its invocation.
//
// Developer notes: future modifications to allow zipped files could be useful
//
// IMMEDIATE NEEDS:
// ****Need to pull the machine name from the file
// ****Need to additional filtering to remove bogus reads.
//=============================================================================

//Load input
// (see above for usage)

outputdir = file(params.path_out) //specify the output directory
dbdir = file(params.dbpath) //specify the reference database path
params.mode = 'denovo'
key = file(params.key) //specify that the demux key is a file
params.threshold = 4

log.info """\
         G B S - N F   P I P E L I N E
         ===================================
         Input fastq file: ${params.in}
         Demultiplexing key: $key
         Output directory: $outputdir
         Contaminant database path: $dbdir
         Mode (should be either denovo or reference): ${params.mode}
         Threshold (sequence depth to be included in assembly): ${params.threshold}
         """
         .stripIndent()

//channel for fastqs that is used to handle multiple files in parallel
fastq_raw = Channel.fromPath(params.in)

//======================================================
// Begin processes

process clean {
  // Remove common contaminants from fastq(s) using tapioca script
  // see: https://github.com/ncgr/tapioca

  input:
    path fastq_file from fastq_raw

  output:
      path 'out.fastq' into clean_out
      stdout ch                           //capture STDOUT

  // Note that Nextflow looks in the bin folder in the dir it is run from.

  // We run tapioca, which does a bowtie alignment to determine sequences that
  // match contaminants. We append (>>) the output of each query to a hits file
  // that will be used to scrub the input fastq.

  script:
  """
  tap_contam_analysis --db ${dbdir}/phix174 --pct 80 ${fastq_file} > hits.txt
  echo "PhiX filtering completed for ${fastq_file}"

  tap_contam_analysis --db ${dbdir}/illumina_oligos --pct 20 ${fastq_file} >> hits.txt
  echo "Illumina adapter filtering completed for ${fastq_file}"

  tap_contam_analysis --db ${dbdir}/ecoli-k-12 --pct 80 ${fastq_file} >> hits.txt
  echo "E. coli filtering completed for ${fastq_file}"

  # Originally, scrubbing done via fqu-cull. But that program requires
  # compilation, which has led to cryptic problems on my system due to the
  # declaration of the sleep command.
  # cat ${fastq_file} | fqu_cull -r hits.txt

  # New solution uses tools basic to Linux.
  # See http://thegenomefactory.blogspot.com/2012/05/cool-use-of-unix-paste-with-ngs.html
  # and https://github.com/lh3/seqtk/issues/62
  # Paste is dope
  # The v flag to grep inverts the search. The F flag makes the input lines
  # a literal query, thus avoiding the regex metacharacters that would be present
  # in a fastq file. The f flag means the input queries are in a file.

  cut -f 1 hits.txt > hitheader
  cat ${fastq_file} | paste - - - - | grep -v -F -f hitheader | tr "\t" "\n" > out.fastq
  """
}
ch.view { print "$it" } //print stdout

//======================================================
process demux {
  // Take fastq(s) as input and demultiplex them using a perl script written
  // by C. Alex Buerkle and Z. Gompert. This script can handle variable
  // length barcodes from 8 to 10 bases long and allows for one base mismatch
  // correction.

  //

  // We publish the output of this process to our output directory.
  // This copies the output from the working directory that Nextflow builds
  // the default is to make a symbolic link. However, if one wants to delete
  // the working directory then copying these intermediate outputs is a
  // way to retain them.

  publishDir "$params.path_out", pattern: "parsereport*", mode: 'copy'

  input:
    path fastq_file from clean_out

  output:
    path 'parsed_out.fastq' into demux_out

  script:
  """
  parse_barcodes768.pl ${key} ${fastq_file} K00188
  """
}

//======================================================
process split_files {
  // Take demultiplexed fastq and split into files for each sample
  // I shifted to a Python script that I found online and modified because
  // Python is easier to read than Perl.

  // Copy the split files to the output directory. In the future this might
  // be better implemented as an option, as it will eat up disk and increase
  // runtime substantially.

  publishDir "$params.path_out", pattern: "*", mode: 'copy'

  input:
    path fastq_file from demux_out

  output:
    path '*fastq' into split_out

  script:
  """
  split_by_header_nofolder.py ${fastq_file}
  """
}
//======================================================
process dereplicate {
  // Find all unique sequences in each sample.

  // publishDir "$params.path_out", pattern: "*", mode: 'rellink'

  input:
    path fastq_file from split_out.flatten()

  output:
    path '*fastq' into derep_out

  script:
  """
  vsearch --fastx_uniques ${fastq_file} --sizeout --fastaout derep_${fastq_file}
  """
}
//======================================================
derep_out
  .collectFile(name: file('derep.txt'))
  .set {
     join_channel
   }

//======================================================
process remove_uncommon {
  // Dereplicate the combined, previously dereplicated files and keep
  // those sequences that occur N or more times (user defined as --threshold).

  publishDir "$params.path_out", pattern: "*", mode: 'rellink'

  input:
    file fastq_file from join_channel

  output:
    path '*' into remove_uncommon_out

  script:
  """
  cat ${fastq_file} | vsearch --fastx_uniques - --sizein --sizeout --fastaout out.fa
  vsearch --fastx_filter out.fa --minsize ${params.threshold} --fastaout for_assembly.fasta
  """
}
